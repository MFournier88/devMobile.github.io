<!-- index.html -->

<!DOCTYPE html>
<html lang="fr">
<head>
    
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link rel="stylesheet" href="/devMobile.github.io/plugins/prism.css">
    <link rel="stylesheet" href="/devMobile.github.io/styles/main.css">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">

    <script src="/devMobile.github.io/plugins/prism.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz" crossorigin="anonymous"></script>
    <script src="/devMobile.github.io/scripts/includes.js"></script>
   <!-- add icon link -->
   <link rel="icon" href="/devMobile.github.io/images/logo.png"/>
    
    <title>Application Mobile | Cégep Marie-victorin</title>
</head>
<body>
    
    <div w3-include-html="/devMobile.github.io/includes/navBar.html"></div>
    <div class="wrapper"> 
        <div class="safe-area-container main-content">
            <div class="container">
                <hr>
                <h2>Mise en place de Node</h2>
                <ol>
                    <li>Installer curl et unzip <span class="inline-code"><span class="cmd">apt install</span> curl unzip</span></li>
                    <li>
                        <pre><code class="language-bash">
<!--                    --># installs fnm (Fast Node Manager)
<!--                    -->curl -fsSL https://fnm.vercel.app/install | bash
<!--                    -->
<!--                    --># activate fnm
<!--                    -->source ~/.bashrc
<!--                    -->
<!--                    --># download and install Node.js
<!--                    -->fnm use --install-if-missing 22
<!--                    -->
<!--                    --># verifies the right Node.js version is in the environment
<!--                    -->node -v # should print `v22.5.1`
<!--                    -->
<!--                    --># verifies the right npm version is in the environment
<!--                    -->npm -v # should print `10.8.2`
                        </code></pre>
                    </li>
                    <li>Créez vous un dossier nommez CRUD et ouvrez le dans VSCode</li>
                    <li><span class="inline-code"><span class="cmd">npm init</span>  <span class="option">-y</span></span> : démarrer un nouveau projet Node.js, en sautant les étapes interactives de configuration grâce à l'acceptation automatique des valeurs par défaut.</li>
                    <li>Pour pouvoir utiliser  `import` et `export` ainsi que permettre du redémarrage automatique modifier ces 2 lignes dans le fichier package.json
                        <pre><code class="language-json">
<!--                     -->"type": "module",
<!--                     -->"scripts": {
<!--                     -->    "dev": "npx nodemon app.js"
<!--                     -->},
                        </code></pre>
                    </li>
                    <li><span class="inline-code"><span class="cmd">npm install</span> <span class="option">--save-dev</span> nodemon</span> : On utilisera cette librairie pour redémarrer automatiquement le </li>
                    <li><span class="inline-code"><span class="cmd">npm i </span>mysql2</span> :  mysql2 est une librairie pour Node.js qui permet aux applications Node.js d'interagir avec des bases de données MySQL.  </li>
                </ol>
                
                <hr class="section">

                <h2>Variables d'environnement</h2>
                <p>Les variables d'environnement sont utilisées pour sécuriser et paramétrer les applications sans stocker directement ces informations dans le code source. Elles permettent de séparer la configuration des applications (comme les clés d'API, les identifiants de base de données, etc.) de leur logique métier, facilitant ainsi la gestion et le déploiement dans différents environnements (développement, test, production). En outre, l'utilisation de variables d'environnement améliore la sécurité en évitant l'exposition de données sensibles dans le code source et en permettant des ajustements rapides et sûrs de la configuration sans nécessiter de modifications de code.</p>
                <h3>Préparation</h3>
                <ol>
                    <li>Créez un fichier appelé `.env` à la racine de votre projet</li>
                    <li>Ajoutez-y : 
                    <pre><code class="language-html">
<!--                -->MYSQL_HOST='127.0.0.1'
<!--                -->MYSQL_USER='root'
<!--                -->MYSQL_PASSWORD='`votre mdp`'
<!--                -->MYSQL_DATABASE='`Le nom de votre db`'
                    </code></pre>
                    </li>
                    <li><span class="inline-code"><span class="cmd">npm i </span>dotenv</span> :  installe la librairie qui saura gérer les variables d'environnement</li>
                    <li>Lorsque vous voudrez utiliser des variables d'environnement il suffira d'ajouter ce code à votre fichier .js
                        <pre><code class="language-js">
<!--                -->import dotenv from 'dotenv'
<!--                -->dotenv.config()
                        </code></pre>
                    </li>
                    <li>Ensuite vous n'aurez qu'à préfixer les variables par process.env pour y avoir accès (Ex : process.env.MYSQL_HOST)</li>
                </ol>
                
                <hr class="section">

                <h2>Connexion à la bd</h2>
                <p>Voici le code vous permettant de vous connecter à la bd, mettez le dans un fichier nommez <i>database.js</i>. Vous devez au préalable avoir créé vos variables dans le fichier .env qui se situe à la racine du projet</p>
                <pre><code class="language-js">
<!--                -->import mysql from 'mysql2';
<!--                -->import dotenv from 'dotenv';
<!--                -->dotenv.config();
<!--                -->const pool = mysql.createPool({
<!--                -->    host: process.env.MYSQL_HOST,
<!--                -->    user: process.env.MYSQL_USER,
<!--                -->    password: process.env.MYSQL_PASSWORD,
<!--                -->    database: process.env.MYSQL_DATABASE
<!--                -->}).promise()
                </code></pre>
                <p><span class="inline-code"><span class="cmd">node</span> database.js</span> pour tester le fichier.</p>
                <p>Tester en faisant un requête. Ajouter simplement le code suivant pour le test, puis retirer le :</p>
                <pre><code class="language-js">
<!--                -->const [resultat] = await pool.query("SELECT * FROM etudiant")
<!--                -->console.log(resultat)
                </code></pre>
                
                <hr class="section">

                <h2>Promise</h2>
                
                <p>La page de <a href="https://www.w3schools.com/js/js_promise.asp">w3school</a> explique bien ce que c'est qu'une `promise`, mais voici ma traduction francaise :</p>
                <p>Une `promise` est séparé en 2 parties: action et réaction.</p> 
                <div class="container">
                    <p><i>Action</i> : code qui peux prendre un certain temps.</p>
                    <p><i>Réaction</i> : code qui doit attendre la fin de l'exécution pour s'effectuer.</p>
                </div>
                <pre><code class="language-js">
<!--            -->let myPromise = new Promise(function(resolve, reject) {
<!--            -->    // "action" (Peux prendre un certain temps)
<!--            -->    
<!--            -->        resolve(); // Fonction pour retourner un succès
<!--            -->        reject();  // Fonction pour retourner une erreur
<!--            -->    });
<!--            -->    
<!--            -->    // "Réaction" (Doit attendre le retour de l'action)
<!--            -->    myPromise.then(
<!--            -->        function(value) { /* code effectué si action terminé avec resolve() */ },
<!--            -->        function(error) { /* code effectué si action terminé avec reject()  */ }
<!--            -->    );
                </code></pre>
                <p>À quoi ça sert d'avoir une séparation entre le code qui doit 
                   être effectué avant et après la terminaison de l'action, car
                   le code s'effectue de haut en bas? Dans le cas de code synchrone
                   il est inutile d'utiliser des `promise`, mais il y a plusieurs 
                   moments où vous serez obliger d'utiliser de l'asynchrone pour des raisons de performances.</p>

                
                <hr class="section">

                <h2>Programmation asynchrone</h2>

                <p>La programmation asynchrone est utilisée principalement pour améliorer l'efficacité et la réactivité des applications, en particulier dans des environnements où des opérations d'entrée-sortie (I/O) sont fréquentes. Voici quelques utilisations principales de la programmation asynchrone :</p>
                <ol>
                    <li><i>Gestion des Entrées/Sorties (I/O)</i> : Dans les applications web, les opérations telles que les requêtes réseau (API, base de données), la lecture/écriture de fichiers, et autres, peuvent prendre du temps. Utiliser des fonctions asynchrones permet à l'application de continuer à fonctionner pendant que ces opérations sont en cours, évitant ainsi le blocage du thread principal.</li>
                    <li><i>Réactivité de l'Interface Utilisateur </i> : Dans les interfaces utilisateur (UI), les opérations longues, comme le traitement de données ou les calculs intensifs, peuvent rendre l'application non réactive si elles sont exécutées de manière synchrone. En rendant ces opérations asynchrones, l'UI reste fluide et réactive pour l'utilisateur.</li>
                    <li><i>Traitement des Événements</i> : Dans les environnements où des événements peuvent se produire de manière asynchrone (par exemple, des clics utilisateur, des notifications), la programmation asynchrone permet de gérer efficacement ces événements sans interrompre le flux principal de l'application.</li>
                    <li><i>Performances et Scalabilité</i> : En permettant à plusieurs tâches d'être exécutées simultanément ou en parallèle, la programmation asynchrone améliore les performances globales de l'application. Cela est particulièrement important dans les applications nécessitant une gestion efficace des ressources et une scalabilité pour gérer de grandes quantités de données ou de trafic.</li>
                    <li><i>Optimisation du Temps de Chargement</i> : Sur les applications web, le chargement asynchrone des ressources telles que les images, les scripts ou les styles permet d'améliorer la vitesse de chargement global de la page, en chargeant les éléments de manière non bloquante.</li>
                </ol>
                <p>En résumé, la programmation asynchrone est essentielle pour améliorer la réactivité, l'efficacité et les performances des applications modernes, en particulier celles qui interagissent fréquemment avec des ressources externes ou nécessitent un traitement intensif sans bloquer le thread principal.</p>
            
                <h3>Exemple</h3>
                <p>Exécutons d'abors une simulation d'aquisition de données. Créez vous un fichier test.html et copiez-y le code. Ensuite utiliser l'extenstion Live Server pour lancer ce fichier dans votre navigateur. Sinon faites un fichier test.js retirer les balise script et tester avec <span class="inline-code"><span class="cmd">node</span> test.js</span></p>
                <pre><code class="language-js">
<!--                -->&lt;script&gt;
<!--                -->    function fetchDataSync() {
<!--                -->        try {
<!--                -->            // Pour transformer des promesses asynchrones en une simulation de code synchrone il faut les traiters en cascade.        
<!--                -->            // Ceci est à la fois horrible à lire et tout à fait inefficace dans le cas où les fonctions ne dépendent pas l'une de l'autre.
<!--                -->            fetchWeatherData().then(res =&gt; {
<!--                -->                const weatherData = res;
<!--                -->                fetchNewsData().then(resp =&gt; {
<!--                -->                    const newsData = resp;
<!--                -->                    fetchStocksData().then(response =&gt;{
<!--                -->                        const stocksData = response;
<!--                -->                        // Process data
<!--                -->                        console.log(&quot;Sync : &quot;, weatherData, newsData, stocksData);
<!--                -->                    })})})
<!--                -->            
<!--                -->        } catch (error) {
<!--                -->            console.error('Error fetching data:', error);
<!--                -->        }
<!--                -->    }
<!--                -->     // Sim-1
<!--                -->    function fetchWeatherData() {
<!--                -->        
<!--                -->        return new Promise(resolve =&gt; {
<!--                -->            setTimeout(() =&gt; {
<!--                -->                resolve({ temperature: 25, condition: 'Sunny' });
<!--                -->            }, 1000);
<!--                -->        });
<!--                -->    }
<!--                -->     // Sim-2
<!--                -->    function fetchNewsData() {
<!--                -->        return new Promise(resolve =&gt; {
<!--                -->            setTimeout(() =&gt; {
<!--                -->                resolve(['Article 1', 'Article 2', 'Article 3']);
<!--                -->            }, 1500);
<!--                -->        });
<!--                -->    }
<!--                -->     // Sim-3
<!--                -->    function fetchStocksData() {
<!--                -->        return new Promise(resolve =&gt; {
<!--                -->            setTimeout(() =&gt; {
<!--                -->                resolve({ symbol: 'AAPL', price: 150.25 });
<!--                -->            }, 2000);
<!--                -->        });
<!--                -->    }
<!--                -->
<!--                -->
<!--                -->    // La meilleure solution beacoup plus rapide est d'utiliser async/await
<!--                -->    // Vous remarquerez la lisibilité accrue et en testant vous verrez la différence en rapidité.
<!--                -->    async function fetchDataAsync() {
<!--                -->        try {
<!--                -->            const weatherPromise = fetchWeatherDataAsync();
<!--                -->            const newsPromise = fetchNewsDataAsync();
<!--                -->            const stocksPromise = fetchStocksDataAsync();
<!--                -->
<!--                -->            const [weatherData, newsData, stocksData] = await Promise.all([weatherPromise, newsPromise, stocksPromise]);
<!--                -->
<!--                -->            // Process data
<!--                -->            
<!--                -->            console.log(&quot;Async : &quot;, weatherData, newsData, stocksData);
<!--                -->        } catch (error) {
<!--                -->            console.error('Error fetching data:', error);
<!--                -->        }
<!--                -->    }
<!--                -->
<!--                -->    async function fetchWeatherDataAsync() {
<!--                -->        // Simulate fetching weather data asynchronously
<!--                -->        return new Promise(resolve =&gt; {
<!--                -->            setTimeout(() =&gt; {
<!--                -->                resolve({ temperature: 25, condition: 'Sunny' });
<!--                -->            }, 1000);
<!--                -->        });
<!--                -->    }
<!--                -->
<!--                -->    async function fetchNewsDataAsync() {
<!--                -->        // Simulate fetching news data asynchronously
<!--                -->        return new Promise(resolve =&gt; {
<!--                -->            setTimeout(() =&gt; {
<!--                -->                resolve(['Article 1', 'Article 2', 'Article 3']);
<!--                -->            }, 1500);
<!--                -->        });
<!--                -->    }
<!--                -->
<!--                -->    async function fetchStocksDataAsync() {
<!--                -->        // Simulate fetching stocks data asynchronously
<!--                -->        return new Promise(resolve =&gt; {
<!--                -->            setTimeout(() =&gt; {
<!--                -->                resolve({ symbol: 'AAPL', price: 150.25 });
<!--                -->            }, 2000);
<!--                -->        });
<!--                -->    }
<!--                -->    fetchDataSync();
<!--                -->    fetchDataAsync();
<!--                -->&lt;/script&gt;
                </code></pre>
                <p><i>async</i> : Déclare qu'une fonction retourne une promesse. Une fonction marquée async peut contenir des expressions await, qui mettent en pause l'exécution de la fonction asynchrone jusqu'à ce que la promesse soit résolue ou rejetée.</p>
                <p><i>await</i> : Met en pause l'exécution de la fonction asynchrone jusqu'à ce que la promesse soit résolue ou rejetée. On utilise await uniquement à l'intérieur des fonctions déclarées avec async.</p>
                <p><i>Promise.all</i> est une méthode statique qui prend un tableau de promesses en entrée et retourne une nouvelle promesse qui est résolue lorsque toutes les promesses du tableau d'entrée sont résolues, ou rejetée si l'une des promesses est rejetée.</p>
                <div class="exercice">
                    <h2>Pratique</h2>
                    <p>Créez 4 méthodes qui simule la connexion à une bd. Elles auront pour nom fetchLongueur, fetchLargeur, fetchProfondeur, fetchMasseVolumique. Chacune de ces fonctions retournera une promise qui se resoudra en 1s et qui retournera respectivement pour chaque fonction 2,1,4,5. </p>
                    <ol>
                        <li>Faites un programme nommé promise.js qui calcul la masse sans utiliser de async, await ou callback.</li>
                        <li>Faites une programme nommé async.js qui calcul la masse avec async et await</li>
                    </ol>
                    
                </div>
                <button class="btn solutionButton" onclick="toggleVisibilityById('solutionExo1')">Solution</button>
                <div class="solution hidden" id="solutionExo1">
                    <ol>
                        <li>
                            <pre><code class="language-js">
<!--                           -->function calculMasse() {
<!--                           -->    try {
<!--                           -->        // Pour transformer des promesses asynchrones en une simulation de code synchrone il faut les traiters en cascade.        
<!--                           -->        // Ceci est à la fois horrible à lire et tout à fait inefficace dans le cas où les fonctions ne dépendent pas l'une de l'autre.
<!--                           -->        fetchLongueur().then(res => {
<!--                           -->            let masse = res;
<!--                           -->            fetchLargeur().then(resp => {
<!--                           -->                masse *= resp;
<!--                           -->                fetchProfondeur().then(response =>{
<!--                           -->                    masse *= response;
<!--                           -->                    fetchMasseVolumique().then(response2 => {
<!--                           -->                        masse *= response2
<!--                           -->                        // Process data
<!--                           -->                        console.log("Sync : ", masse);
<!--                           -->                    })
<!--                           -->                })
<!--                           -->            })
<!--                           -->        })
<!--                           -->        
<!--                           -->    } catch (error) {
<!--                           -->        console.error('Error fetching data:', error);
<!--                           -->    }
<!--                           -->}
<!--                           --> // Sim-1
<!--                           -->function fetchLongueur() {
<!--                           -->    
<!--                           -->    return new Promise(resolve => {
<!--                           -->        setTimeout(() => {
<!--                           -->            resolve(2);
<!--                           -->        }, 1000);
<!--                           -->    });
<!--                           -->}
<!--                           --> // Sim-2
<!--                           -->function fetchLargeur() {
<!--                           -->    return new Promise(resolve => {
<!--                           -->        setTimeout(() => {
<!--                           -->            resolve(1);
<!--                           -->        }, 1000);
<!--                           -->    });
<!--                           -->}
<!--                           --> // Sim-3
<!--                           -->function fetchProfondeur() {
<!--                           -->    return new Promise(resolve => {
<!--                           -->        setTimeout(() => {
<!--                           -->            resolve(4);
<!--                           -->        }, 1000);
<!--                           -->    });
<!--                           -->}
<!--                           --> // Sim-3
<!--                           --> function fetchMasseVolumique() {
<!--                           -->    return new Promise(resolve => {
<!--                           -->        setTimeout(() => {
<!--                           -->            resolve(5);
<!--                           -->        }, 1000);
<!--                           -->    });
<!--                           -->}
<!--                           -->calculMasse();
                            </code></pre>
                        </li>
                        <li>
                            <pre><code class="language-js">
<!--                        -->async function calculMasseAsync() {
<!--                        -->    try {
<!--                        -->        // Pour transformer des promesses asynchrones en une simulation de code synchrone il faut les traiters en cascade.        
<!--                        -->        // Ceci est à la fois horrible à lire et tout à fait inefficace dans le cas où les fonctions ne dépendent pas l'une de l'autre.
<!--                        -->        const longueur = fetchAsyncLongueur()
<!--                        -->        const largeur = fetchAsyncLargeur()
<!--                        -->        const profondeur = fetchAsyncProfondeur()
<!--                        -->        const masseVolumique = fetchAsyncMasseVolumique()
<!--                        -->
<!--                        -->        const [longueurData, largeurData, profondeurData, masseVolumiqueData] = await Promise.all([longueur, largeur, profondeur, masseVolumique])
<!--                        -->        console.log("Async : ", longueurData*largeurData*profondeurData*masseVolumiqueData)
<!--                        -->    } catch (error) {
<!--                        -->        console.error('Error fetchAsyncing data:', error);
<!--                        -->    }
<!--                        -->}
<!--                        --> // Sim-1
<!--                        -->async function fetchAsyncLongueur()  {
<!--                        -->    
<!--                        -->    return new Promise(resolve => {
<!--                        -->        setTimeout(() => {
<!--                        -->            resolve(2);
<!--                        -->        }, 1000);
<!--                        -->    });
<!--                        -->}
<!--                        --> // Sim-2
<!--                        -->async function fetchAsyncLargeur() {
<!--                        -->    return new Promise(resolve => {
<!--                        -->        setTimeout(() => {
<!--                        -->            resolve(1);
<!--                        -->        }, 1000);
<!--                        -->    });
<!--                        -->}
<!--                        --> // Sim-3
<!--                        -->async function fetchAsyncProfondeur() {
<!--                        -->    return new Promise(resolve => {
<!--                        -->        setTimeout(() => {
<!--                        -->            resolve(4);
<!--                        -->        }, 1000);
<!--                        -->    });
<!--                        -->}
<!--                        --> // Sim-3
<!--                        --> async function fetchAsyncMasseVolumique() {
<!--                        -->    return new Promise(resolve => {
<!--                        -->        setTimeout(() => {
<!--                        -->            resolve(5);
<!--                        -->        }, 1000);
<!--                        -->    });
<!--                        -->}
<!--                        -->calculMasseAsync();                        
                            </code></pre>
                        </li>
                        
                    </ol>
                    
                </div>
                <hr class="section">

                <h2>Requêtes</h2>
                <div class="exercice">
                    <h2>Créez cette table dans votre bd</h2>
                    <img style="margin: 0 auto;display:block;" src="/devMobile.github.io/images/exo1-backend-setup-1.PNG" alt="Table à recréer">
                </div>
                <button class="btn solutionButton" onclick="toggleVisibilityById('solutionExo2')">Solution</button>
                <div class="solution hidden" id="solutionExo2">
                    <ol>
                        <li>
                            <pre><code class="language-sql">
<!--                            -->CREATE TABLE parc_attraction ( 
<!--                            -->    id INT AUTO_INCREMENT PRIMARY KEY,
<!--                            -->    nom VARCHAR(100), 
<!--                            -->    ville VARCHAR(500), 
<!--                            -->    cout_billet DECIMAL(6,2) 
<!--                            -->    );
                            </code></pre>
                        </li>
                        <li>
                            <pre><code class="language-js">
<!--                            -->#!/bin/bash

<!--                            --># Define variables
<!--                            -->DB_NAME="mobile"
<!--                            -->DB_USER="root"
<!--                            -->DB_PASS="abc-123"
<!--                            -->DB_HOST="localhost"
<!--                            -->
<!--                            --># Create database
<!--                            -->mysql -h $DB_HOST -u $DB_USER -p$DB_PASS -e "use $DB_NAME;INSERT INTO parc_attraction (nom, ville, cout_billet) VALUES ('La Ronde','Montréal','55.99'),('Disney','Orlando','99.49');"
                            </code></pre>
                        </li>
                        
                    </ol>
                    
                </div>
               


                <p>Dans database.js nous allons maintenant créez des requêtes simples :</p>
                <pre><code class="language-js">
<!--                -->// Ce code fonctionne car await peut être utiliser au `Top-level`
<!--                -->const [resultat] = await pool.query("SELECT * FROM parc_attraction")
<!--                -->console.log(resultat)

<!--                -->// si vous prévoyer utiliser ce code plus d'une fois, il est plus propre de le mettre dans une fonction async
<!--                -->async function getParcAttraction() {
<!--                -->     const [rows] = await pool.query("SELECT * FROM parc_attraction")
<!--                -->     return rows
<!--                -->}
<!--                -->const parc = await getParcAttraction()
<!--                -->console.log(parc)

                </code></pre>
                <div class="exercice">
                    <h2>Pratique - Requêtes</h2>
                    <ol>
                        <li>Faites un code qui affiche les lignes de la table parc d'attraction, en ajoute 2 nouvelles, affiche encore une fois toutes les lignes puis supprime les 2 lignes créez et affiche une dernière fois toutes les lignes de la table.</li>
                        <li>Utiliser le code suivant : 
                            <pre><code class="language-js">
<!--                        -->async function getParcAttraction(id) {
<!--                        -->    return new Promise(resolve => {
<!--                        -->        setTimeout(async () => {
<!--                        -->            const demande = "SELECT * FROM parc_attraction WHERE id=" + id;
<!--                        -->            const [rows] = await pool.query(demande)
<!--                        -->            resolve(rows[0]);
<!--                        -->        }, 4000);
<!--                        -->    })    
<!--                        -->}
                            </code></pre>
                            Vous devez utilisez ce code pour afficher "Disney La Ronde" en utilisant seulement leur id, cette fonction et ce en moins de 5s. (indice vous avez droit à Promise.all)
                        </li>
                    </ol>
                   
                    
                </div>
                
                <button class="btn solutionButton" onclick="toggleVisibilityById('solutionExo3')">Solution</button>
                <div class="solution hidden" id="solutionExo3">
                    <ol>
                       
                        <li>
                            <pre><code class="language-js">
<!--                            -->// si vous prévoyer utiliser ce code plus d'une fois, il est plus propre de le mettre dans une fonction async
<!--                            -->async function getParcAttraction() {
<!--                            -->     const [rows] = await pool.query("SELECT * FROM parc_attraction;")
<!--                            -->     return rows
<!--                            -->}
<!--                            -->
<!--                            -->// si vous prévoyer utiliser ce code plus d'une fois, il est plus propre de le mettre dans une fonction async
<!--                            -->async function addParcAttraction(nom,ville,cout) {
<!--                            -->    const [rows] = await pool.query(`INSERT INTO parc_attraction (nom, ville, cout_billet) VALUES ('${nom}','${ville}','${cout}');`)
<!--                            -->    return rows
<!--                            -->}
<!--                            -->
<!--                            -->// si vous prévoyer utiliser ce code plus d'une fois, il est plus propre de le mettre dans une fonction async
<!--                            -->async function removeParcAttractionByName(nom) {
<!--                            -->    const [rows] = await pool.query(`DELETE FROM parc_attraction 
<!--                            -->                                     WHERE nom='${nom}';`)
<!--                            -->    return rows
<!--                            -->}
<!--                            -->
<!--                            -->const parc = await getParcAttraction()
<!--                            -->console.log(parc)
<!--                            -->
<!--                            -->const ajout1 = await addParcAttraction('Super Aqua CLub', 'Pointe-Calumet', 60)
<!--                            -->const ajout2 = await addParcAttraction('Bromont','Bromont',50)
<!--                            -->
<!--                            -->const parc2 = await getParcAttraction()
<!--                            -->console.log(parc2)
<!--                            -->
<!--                            -->const ret1 = await removeParcAttractionByName("Super Aqua CLub");
<!--                            -->const ret2 = await removeParcAttractionByName("Bromont");
<!--                            -->
<!--                            -->const parc3 = await getParcAttraction()
<!--                            -->console.log(parc3)
                            </code></pre>
                        </li>
                        <li>
                            <pre><code class="language-js">
<!--                            -->import mysql from 'mysql2';
<!--                            -->import dotenv from 'dotenv';
<!--                            -->dotenv.config();
<!--                            -->const pool = mysql.createPool({
<!--                            -->    host: process.env.MYSQL_HOST,
<!--                            -->    user: process.env.MYSQL_USER,
<!--                            -->    password: process.env.MYSQL_PASSWORD,
<!--                            -->    database: process.env.MYSQL_DATABASE
<!--                            -->}).promise()
<!--                            -->
<!--                            -->async function getParcAttraction(id) {
<!--                            -->    return new Promise(resolve => {
<!--                            -->        setTimeout(async () => {
<!--                            -->            const demande = "SELECT * FROM parc_attraction WHERE id=" + id;
<!--                            -->            const [rows] = await pool.query(demande)
<!--                            -->            resolve(rows[0]);
<!--                            -->        }, 4000);
<!--                            -->    })    
<!--                            -->}
<!--                            -->
<!--                            -->const parc1 =  getParcAttraction(1);
<!--                            -->const parc2 =  getParcAttraction(2);
<!--                            -->const [parc1Data, parc2Data] = await Promise.all([parc1,parc2])
<!--                            -->console.log(parc2Data.nom + " " + parc1Data.nom )
                            </code></pre>
                        </li>
                    </ol>
                </div>

                <hr class="section">

                <h2>Requête préparée</h2>
                <ol>
                    <li><i>Sécurité contre les injections SQL</i> :
                        Les requêtes préparées aident à prévenir les attaques par injection SQL en séparant les données des instructions SQL. Avec les requêtes préparées, les valeurs des paramètres sont transmises séparément de la requête SQL elle-même, ce qui empêche les attaquants d'injecter du code SQL malveillant via les données utilisateur. Cela garantit une meilleure sécurité des données et protège contre les vulnérabilités courantes comme les attaques par injection SQL.
                    </li>
                    <li><i>Performance optimisée</i>: Les bases de données peuvent optimiser l'exécution de requêtes préparées en les compilant une seule fois et en réutilisant le plan d'exécution pour les requêtes similaires avec des paramètres différents. Cela peut réduire la charge sur la base de données et améliorer les performances, surtout lorsque les mêmes requêtes sont exécutées fréquemment avec différents paramètres.</li>
                    <li><i> Clarté du code et maintenance simplifiée</i> : Les requêtes préparées rendent le code plus lisible et plus facile à maintenir en séparant clairement la logique de la requête SQL de ses données. Cela facilite la gestion des modifications ultérieures de requêtes sans avoir à réécrire le code SQL principal.</li>
                </ol>
                <p>Reprenons l'exemple précédent sans le timeout et transformons la requête en requête préparée</p>
                <pre><code class="language-js">
<!--            -->async function getParcAttraction(id) {
<!--            -->     const [rows] = await pool.query(`SELECT * FROM parc_attraction WHERE id=?`,[id])
<!--            -->     return rows[0];
<!--            -->}
                </code></pre>
                <div class="exercice">
                    <h2>Exercices</h2>
                    Faites un CRUD basique avec les fonction async suivante:
                    <ol>
                        <li>Création d'un parc d'attraction en prenant les données en paramètre</li>
                        <li>Lire une ligne en donnant l'id en paramètre</li>
                        <li>Lire toute les lignes de la table</li>
                        <li>Modifier une ligne de la table en prenant en paramètre toutes les données (id, nom, ville, cout du billet)</li>
                        <li>Supprimer une ligne en prenant en paramètre l'id</li>
                    </ol>
                </div>
                <button class="btn solutionButton" onclick="toggleVisibilityById('solutionExo4')">Solution</button>
                <div class="solution hidden" id="solutionExo4">
                    <ol>
                       
                        <li>
                            <pre>
                                <code class="language-js">

<!--                            -->import mysql from 'mysql2';
<!--                            -->import dotenv from 'dotenv';
<!--                            -->dotenv.config();
<!--                            -->const pool = mysql.createPool({
<!--                            -->    host: process.env.MYSQL_HOST,
<!--                            -->    user: process.env.MYSQL_USER,
<!--                            -->    password: process.env.MYSQL_PASSWORD,
<!--                            -->    database: process.env.MYSQL_DATABASE
<!--                            -->}).promise()
<!--                            -->
<!--                            -->// si vous prévoyer utiliser ce code plus d'une fois, il est plus propre de le mettre dans une fonction async
<!--                            -->async function addParcAttraction(nom,ville,cout) {
<!--                            -->    const [rows] = await pool.query(`INSERT INTO parc_attraction (nom, ville, cout_billet) VALUES (?,?,?);`,[nom,ville,cout])
<!--                            -->    return rows
<!--                            -->}
<!--                            -->async function getParcAttraction(id) {
<!--                            -->    const [rows] = await pool.query("SELECT * FROM parc_attraction where id=?;",[id])
<!--                            -->    return rows
<!--                            -->}
<!--                            -->// si vous prévoyer utiliser ce code plus d'une fois, il est plus propre de le mettre dans une fonction async
<!--                            -->async function getParcAttractions() {
<!--                            -->     const [rows] = await pool.query("SELECT * FROM parc_attraction;")
<!--                            -->     return rows
<!--                            -->}
<!--                            -->
<!--                            -->// si vous prévoyer utiliser ce code plus d'une fois, il est plus propre de le mettre dans une fonction async
<!--                            -->async function updateParcAttraction(id,nom,ville,cout) {
<!--                            -->    const [rows] = await pool.query(`UPDATE parc_attraction 
<!--                            -->                                     SET nom=?, ville=?, cout_billet=?
<!--                            -->                                     WHERE id=?;`,[nom,ville,cout,id])
<!--                            -->    return rows
<!--                            -->}
<!--                            -->
<!--                            -->
<!--                            -->
<!--                            -->// si vous prévoyer utiliser ce code plus d'une fois, il est plus propre de le mettre dans une fonction async
<!--                            -->async function removeParcAttractionByName(nom) {
<!--                            -->    const [rows] = await pool.query(`DELETE FROM parc_attraction 
<!--                            -->                                     WHERE nom=?;`,[nom])
<!--                            -->    return rows
<!--                            -->}
<!--                            -->
<!--                            -->const step1 = await getParcAttraction(1);
<!--                            -->console.log(step1);
<!--                            -->
<!--                            -->const step2 = await addParcAttraction("Bidon","lol",1000);
<!--                            -->const step3 = await getParcAttractions();
<!--                            -->console.log(step3);
<!--                            -->
<!--                            -->const step4 = await updateParcAttraction(1,"changed","Montréal",10);
<!--                            -->const step5 = await getParcAttractions();
<!--                            -->console.log(step5);
<!--                            -->
<!--                            -->const step6 = await updateParcAttraction(1,"La Ronde","Montréal",55.99);
<!--                            -->const step7 = await removeParcAttractionByName("Bidon");
<!--                            -->const step8 = await getParcAttractions();
<!--                            -->console.log(step8);
                                </code>
                            </pre>
                        </li>
                    </ol>
                </div>
                <hr class="section">
                
                <h2>Express</h2>
                <p>Dans votre projet CRUD, dans le fichier `database.js`, exporter toutes les  fonctions pour pouvoir les utiliser dans un autre module.</p>
                
                <pre><code class="language-js">
<!--                -->export async function getParcAttractions() {
<!--                -->    const [rows] = await pool.query("SELECT * FROM parc_attraction")
<!--                -->    return rows
<!--                -->}
                </code></pre>
                <ol>
                    <li>Créez votre fichier app.js. Assurez-vous que l'option main dans package.json soit : <span class="inline-code"><span class="jskey">"main":</span>&nbsp;<span class="jsString">"app.js"</span></span>.</li>
                    <li>Mettez-y ce code de base d'une application express:
                        <pre><code class="language-js">
<!--                    -->import express from 'express';
<!--                    -->// Ces fonctions sont celles que nous avons créé précédemment, assurez vous que l'importation réussit                
<!--                    -->import {getParcAttractions, getParcAttraction} from "./database.js"
<!--                    -->
<!--                    -->const app = express();
<!--                    -->
<!--                    -->// app.use(express.json()) est une instruction cruciale pour configurer Express afin de gérer et d'interpréter
<!--                    -->//   automatiquement les données JSON envoyées via les requêtes HTTP, facilitant ainsi le développement d'applications
<!--                    -->//   web basées sur Node.js avec Express.
<!--                    -->app.use(express.json())
<!--                    -->app.get("/parc-attractions", async (req,res) => {
<!--                    -->    const parcs = await getParcAttractions()
<!--                    -->    res.send(parcs)
<!--                    -->})
<!--                    -->app.get("/parc-attraction/:id", async (req,res) => {
<!--                    -->    const id = req.params.id
<!--                    -->    const employee = await getParcAttraction(id)
<!--                    -->    res.send(employee)
<!--                    -->})
<!--                    -->
<!--                    -->// Lorsqu'une erreur se produit dans l'application (par exemple, une exception non gérée), Express appelle automatiquement
<!--                    -->// ce middleware d'erreur avec l'objet d'erreur (err), ce qui permet de la gérer de manière centralisée et uniforme.
<!--                    -->app.use((err, req, res, next) => {
<!--                    -->    console.error(err.stack)
<!--                    -->    res.status(1045).send('Something broke!')
<!--                    -->})
<!--                    -->
<!--                    -->// Lance le serveur et lui indique quel port utiliser 
<!--                    -->app.listen(8080, () => {
<!--                    -->    console.log('Server is runnig on port 8080')
<!--                    -->})
                        </code></pre>
                    </li>
                    <li>Lancer le server avec <span class="inline-code"><span class="cmd">npm run</span> dev</span></li>
                    <li><a target="_blank" href="http://127.0.0.1:8080/parc-attractions">Ouvrez le lien 127.0.0.1:8080/parc-attractions</a></li>
                    
                </ol>
                <hr>
                <h2>Restfull</h2>
                <p>Pour la version longue des explications visiter le <a href="https://learn.microsoft.com/en-us/azure/architecture/best-practices/api-design">site</a> par microsoft.</p>
                
                <p>Les API REST (Representational State Transfer) sont un ensemble de conventions pour concevoir des services web qui permettent aux applications de communiquer entre elles. Voici les concepts clés :</p>
                <p class="gras">1. Ressources</p>
                <p>Les API REST manipulent des "ressources", qui sont des objets ou des données. Chaque ressource est identifiée par une URL unique (ex. : /utilisateurs/123).</p>
                <p class="gras">2. Méthodes HTTP</p>
                <p>Les API REST utilisent les méthodes HTTP pour effectuer des opérations sur les ressources :</p>
                <ul>
                    
                    <li>GET : Récupérer une ressource.</li>
                    <li>POST : Créer une nouvelle ressource.</li>
                    <li>PUT : Mettre à jour une ressource existante.</li>
                    <li>DELETE : Supprimer une ressource.</li>
                </ul>
                <p class="gras">3. Formats de données</p>
                <p>Les réponses des API REST sont généralement formatées en JSON (JavaScript Object Notation) ou XML. JSON est le plus courant en raison de sa simplicité et de sa légèreté.</p>
                <p class="gras">4. Utilisation des Codes de Statut HTTP</p>
                <p>Les API REST utilisent des codes de statut HTTP pour indiquer le résultat d'une requête :</p>
                <ul>
                    
                    <li>200 OK : Requête réussie.</li>
                    <li>201 Created : Nouvelle ressource créée avec succès.</li>
                    <li>204 No Content : Requête réussie, mais aucune donnée à retourner.</li>
                    <li>400 Bad Request : Erreur de la part du client.</li>
                    <li>404 Not Found : La ressource demandée n'existe pas.</li>
                    <li>500 Internal Server Error : Erreur côté serveur.</li>
                </ul>

                
            </div>
        </div>

        
    <div w3-include-html="includes/vertNavBar.html"></div> 
    <div w3-include-html="/devMobile.github.io/includes/footer.html"></div> 
        
    </div>
    
    <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.5.4/dist/umd/popper.min.js"></script>
    <script src="/devMobile.github.io/scripts/main.js"></script>
    <script> focusOnNavbar("nav-link-be")</script>
    
</body>
</html>